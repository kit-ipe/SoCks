import sys
import pathlib
import shutil
import hashlib
import tarfile
import stat
import urllib
import validators

import socks.pretty_print as pretty_print
from socks.builder import Builder
from builders.zynqmp_amd_petalinux_rootfs_builder_alma8 import ZynqMP_AMD_PetaLinux_RootFS_Builder_Alma8

class ZynqMP_AMD_PetaLinux_RAMFS_Builder_Alma8(ZynqMP_AMD_PetaLinux_RootFS_Builder_Alma8):
    """
    AMD PetaLinux RAM file system builder class
    """

    def __init__(self, project_cfg: dict, project_cfg_files: list, socks_dir: pathlib.Path, project_dir: pathlib.Path, block_id: str = 'ramfs', block_description: str = 'Build an AMD PetaLinux RAM file system'):

        super().__init__(project_cfg=project_cfg,
                        project_cfg_files=project_cfg_files,
                        socks_dir=socks_dir,
                        project_dir=project_dir,
                        block_id=block_id,
                        block_description=block_description)


    def build_archive(self, prebuilt: bool = False):
        """
        Packs the entire rootfs in a archive.

        Args:
            prebuilt:
                Set to True if the archive will contain pre-built files
                instead of a complete project file system.

        Returns:
            None

        Raises:
            None
        """

        # Check if the archive needs to be built
        if not ZynqMP_AMD_PetaLinux_RAMFS_Builder_Alma8._check_rebuild_required(src_search_list=self._project_cfg_files + [self._work_dir], out_search_list=[self._output_dir]):
            pretty_print.print_build('No need to rebuild archive. No altered source files detected...')
            return

        self.clean_output()
        self._output_dir.mkdir(parents=True)

        pretty_print.print_build('Building archive...')

        if self._pc_project_build_info_flag == True:
            # Add build information file
            with self._build_info_file.open('w') as f:
                print('# Filesystem build info (autogenerated)\n\n', file=f, end='')
                print(self._compose_build_info(), file=f, end='')

            add_build_info_commands = f'\'mv {self._build_info_file} {self._mod_dir}/etc/fs_build_info && ' \
                                        f'chmod 0444 {self._mod_dir}/etc/fs_build_info\''

            if self._pc_container_tool  in ('docker', 'podman'):
                try:
                    # Run commands in container
                    # The root user is used in this container. This is necessary in order to build a RootFS image.
                    ZynqMP_AMD_PetaLinux_RAMFS_Builder_Alma8._run_sh_command([self._pc_container_tool , 'run', '--rm', '-it', '-u', 'root', '-v', f'{self._work_dir}:{self._work_dir}:Z', self._container_image, 'sh', '-c', add_build_info_commands])
                except Exception as e:
                    pretty_print.print_error(f'An error occurred while adding the build info file to the root file system: {e}')
                    sys.exit(1)
            elif self._pc_container_tool  == 'none':
                # Run commands without using a container
                # The use of sudo is necessary in order to build a RootFS image.
                ZynqMP_AMD_PetaLinux_RAMFS_Builder_Alma8._run_sh_command(['sudo', 'sh', '-c', add_build_info_commands])
            else:
                self._err_unsup_container_tool()
        else:
            # Remove existing build information file
            clean_build_info_commands = f'\'rm -f {self._build_dir}/etc/fs_build_info\''

            if self._pc_container_tool  in ('docker', 'podman'):
                try:
                    # Run commands in container
                    # The root user is used in this container. This is necessary in order to build a RootFS image.
                    ZynqMP_AMD_PetaLinux_RAMFS_Builder_Alma8._run_sh_command([self._pc_container_tool , 'run', '--rm', '-it', '-u', 'root', '-v', f'{self._work_dir}:{self._work_dir}:Z', self._container_image, 'sh', '-c', clean_build_info_commands])
                except Exception as e:
                    pretty_print.print_error(f'An error occurred while cleaning the build info file from the root file system: {e}')
                    sys.exit(1)
            elif self._pc_container_tool  == 'none':
                # Run commands without using a container
                # The use of sudo is necessary in order to build a RootFS image.
                ZynqMP_AMD_PetaLinux_RAMFS_Builder_Alma8._run_sh_command(['sudo', 'sh', '-c', clean_build_info_commands])
            else:
                self._err_unsup_container_tool()

        if prebuilt:
            archive_name = f'petalinux_zynqmp_pre-built'
        else:
            archive_name = self._rootfs_name

        archive_build_commands = f'\'cd {self._mod_dir} && ' \
                                f'find . | cpio -H newc -o | gzip -9 > {self._output_dir / f"{archive_name}.cpio.gz"} && ' \
                                f'if id {self._host_user} >/dev/null 2>&1; then ' \
                                f'    chown -R {self._host_user}:{self._host_user} {self._output_dir / f"{archive_name}.cpio.gz"}; ' \
                                f'fi\''

        if self._pc_container_tool  in ('docker', 'podman'):
            try:
                # Run commands in container
                # The root user is used in this container. This is necessary in order to build a RootFS image.
                ZynqMP_AMD_PetaLinux_RAMFS_Builder_Alma8._run_sh_command([self._pc_container_tool , 'run', '--rm', '-it', '-u', 'root', '-v', f'{self._work_dir}:{self._work_dir}:Z', '-v', f'{self._output_dir}:{self._output_dir}:Z', self._container_image, 'sh', '-c', archive_build_commands])
            except Exception as e:
                pretty_print.print_error(f'An error occurred while building the archive: {e}')
                sys.exit(1)
        elif self._pc_container_tool  == 'none':
            # Run commands without using a container
            # The use of sudo is necessary in order to build a RootFS image.
            ZynqMP_AMD_PetaLinux_RAMFS_Builder_Alma8._run_sh_command(['sudo', 'sh', '-c', archive_build_commands])
        else:
            self._err_unsup_container_tool()