import sys
import pathlib
import shutil
import hashlib
import tarfile
import stat
import urllib
import validators
import inspect

import socks.pretty_print as pretty_print
from builders.zynqmp_amd_petalinux_rootfs_builder import ZynqMP_AMD_PetaLinux_RootFS_Builder
from builders.zynqmp_amd_petalinux_ramfs_model import ZynqMP_AMD_PetaLinux_RAMFS_Model


class ZynqMP_AMD_PetaLinux_RAMFS_Builder(ZynqMP_AMD_PetaLinux_RootFS_Builder):
    """
    AMD PetaLinux RAM file system builder class
    """

    def __init__(
        self,
        project_cfg: dict,
        socks_dir: pathlib.Path,
        project_dir: pathlib.Path,
        block_id: str = "ramfs",
        block_description: str = "Build an AMD PetaLinux RAM file system",
        model_class: type[object] = ZynqMP_AMD_PetaLinux_RAMFS_Model,
    ):

        super().__init__(
            project_cfg=project_cfg,
            socks_dir=socks_dir,
            project_dir=project_dir,
            block_id=block_id,
            block_description=block_description,
            model_class=model_class,
        )

    def build_archive(self, prebuilt: bool = False):
        """
        Packs the entire ram file system in a archive.

        Args:
            prebuilt:
                Set to True if the archive will contain pre-built files
                instead of a complete project file system.

        Returns:
            None

        Raises:
            None
        """

        # Check if the archive needs to be built
        if not ZynqMP_AMD_PetaLinux_RAMFS_Builder._check_rebuild_bc_timestamp(
            src_search_list=[self._work_dir],
            out_timestamp=self._build_log.get_logged_timestamp(
                identifier=f"function-{inspect.currentframe().f_code.co_name}-success"
            ),
        ) and not self._check_rebuild_bc_config(
            keys=[["blocks", self.block_id, "project", "add_build_info"], ["project", "name"]]
        ):
            pretty_print.print_build("No need to rebuild archive. No altered source files detected...")
            return

        # Reset function success log
        self._build_log.del_logged_timestamp(identifier=f"function-{inspect.currentframe().f_code.co_name}-success")

        self.clean_output()
        self._output_dir.mkdir(parents=True)

        pretty_print.print_build("Building archive...")

        if self.block_cfg.project.add_build_info == True:
            # Add build information file
            with self._build_info_file.open("w") as f:
                print("# Filesystem build info (autogenerated)\n\n", file=f, end="")
                print(self._compose_build_info(), file=f, end="")

            add_build_info_commands = [
                f"mv {self._build_info_file} {self._mod_dir}/etc/fs_build_info",
                f"chmod 0444 {self._mod_dir}/etc/fs_build_info",
            ]

            # The root user is used in this container. This is necessary in order to build a RootFS image.
            self.container_executor.exec_sh_commands(
                commands=add_build_info_commands, dirs_to_mount=[(self._work_dir, "Z")], run_as_root=True
            )
        else:
            # Remove existing build information file
            clean_build_info_commands = [f"rm -f {self._mod_dir}/etc/fs_build_info"]

            # The root user is used in this container. This is necessary in order to build a RootFS image.
            self.container_executor.exec_sh_commands(
                commands=clean_build_info_commands, dirs_to_mount=[(self._work_dir, "Z")], run_as_root=True
            )

        if prebuilt:
            archive_name = f"petalinux_zynqmp_pre-built"
        else:
            archive_name = self._rootfs_name

        archive_build_commands = [
            f"cd {self._mod_dir}",
            f"find . | cpio -H newc -o | gzip -9 > {self._output_dir / f'{archive_name}.cpio.gz'}",
            f"if id {self._host_user} >/dev/null 2>&1; then "
            f"    chown -R {self._host_user}:{self._host_user} {self._output_dir / f'{archive_name}.cpio.gz'}; "
            f"fi",
        ]

        # The root user is used in this container. This is necessary in order to build a RootFS image.
        self.container_executor.exec_sh_commands(
            commands=archive_build_commands,
            dirs_to_mount=[(self._work_dir, "Z"), (self._output_dir, "Z")],
            run_as_root=True,
        )

        # Log success of this function
        self._build_log.log_timestamp(identifier=f"function-{inspect.currentframe().f_code.co_name}-success")

    def import_prebuilt(self):
        """
        Imports a pre-built ram file system.

        Args:
            None

        Returns:
            None

        Raises:
            None
        """

        # Get path of the pre-built ram file system
        if self.block_cfg.project.import_src is None:
            pretty_print.print_error(
                f"The property blocks/{self.block_id}/project/import_src is required to import the block, but it is not set."
            )
            sys.exit(1)
        elif urllib.parse.urlparse(self.block_cfg.project.import_src).scheme == "file":
            prebuilt_block_package = pathlib.Path(urllib.parse.urlparse(self.block_cfg.project.import_src).path)
        elif validators.url(self.block_cfg.project.import_src):
            self._download_prebuilt()
            downloads = list(self._download_dir.glob("*"))
            # Check if there is more than one file in the download directory
            if len(downloads) != 1:
                pretty_print.print_error(f"Not exactly one file in {self._download_dir}")
                sys.exit(1)
            prebuilt_block_package = downloads[0]
        else:
            raise ValueError(
                "The following string is not a valid reference to a block package: "
                f"{self.block_cfg.project.import_src}. Only URI schemes 'https', 'http', and 'file' "
                "are supported."
            )

        # Check whether the file is a supported archive
        if prebuilt_block_package.name.partition(".")[2] not in ["tar.gz", "tgz", "tar.xz", "txz"]:
            pretty_print.print_error(
                f'Unable to import block package. The following archive type is not supported: {prebuilt_block_package.name.partition(".")[2]}'
            )
            sys.exit(1)

        # Calculate md5 of the provided file
        md5_new_file = hashlib.md5(prebuilt_block_package.read_bytes()).hexdigest()
        # Read md5 of previously used file, if any
        md5_existsing_file = 0
        if self._source_pb_md5_file.is_file():
            with self._source_pb_md5_file.open("r") as f:
                md5_existsing_file = f.read()

        # Check if the pre-built ram file system needs to be imported
        if md5_existsing_file == md5_new_file:
            pretty_print.print_build(
                "No need to import the pre-built ram file system. No altered source files detected..."
            )
            return

        self.clean_work()
        self._mod_dir.mkdir(parents=True)

        pretty_print.print_build("Importing pre-built ram file system...")

        # Extract pre-built files
        with tarfile.open(prebuilt_block_package, "r:*") as archive:
            content = archive.getnames()
            # Filter the list to get only .tar.xz and .tar.gz files
            tar_files = [f for f in content if f.endswith((".tar.xz", ".tar.gz"))]
            if len(tar_files) != 1:
                pretty_print.print_error(
                    f"There are {len(tar_files)} *.tar.xz and *.tar.gz files in archive {prebuilt_block_package}. Expected was 1."
                )
                sys.exit(1)
            prebuilt_ramfs_archive = tar_files[0]
            # Extract ramfs archive to the work directory
            archive.extract(member=prebuilt_ramfs_archive, path=self._work_dir)

        extract_pb_ramfs_commands = [
            f'gunzip -c {self._work_dir / prebuilt_ramfs_archive} | sh -c "cd {self._mod_dir}/ && cpio -i"'
        ]

        # The root user is used in this container. This is necessary in order to build a RootFS image.
        self.container_executor.exec_sh_commands(
            commands=extract_pb_ramfs_commands, dirs_to_mount=[(self._work_dir, "Z")], run_as_root=True
        )

        # Save checksum in file
        with self._source_pb_md5_file.open("w") as f:
            print(md5_new_file, file=f, end="")

        # Delete imported, pre-built ramfs archive
        (self._work_dir / prebuilt_ramfs_archive).unlink()
